#ifndef POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
#define POAC_CORE_BUILDER_NINJA_MANIFEST_HPP

// std
#include <array>
#include <filesystem>
#include <fstream>
#include <string>

// external
#include <fmt/core.h>
#include <mitama/result/result.hpp>
#include <mitama/anyhow/anyhow.hpp>
#include <ninja/build.h> // Builder
#include <ninja/graph.h> // Node
#include <toml.hpp>

// internal
#include <poac/core/builder/ninja/syntax.hpp>
#include <poac/core/builder/ninja/data.hpp>
#include <poac/core/builder/compiler.hpp>
#include <poac/core/resolver.hpp> // resolved_deps_t
#include <poac/data/manifest.hpp>
#include <poac/util/misc.hpp>
#include <poac/config.hpp>

namespace poac::core::builder::ninja::manifest {
    namespace fs = std::filesystem;
    namespace anyhow = mitama::anyhow;

    inline const std::string manifest_file_name = "ninja.build";
    inline const std::array<std::string, 2> manifest_headers = {
        "This file is automatically generated by Poac.",
        "It is not intended for manual editing."
    };

    inline fs::file_time_type
    ninja_manifest_last_modified(const fs::path& build_dir) {
        return fs::last_write_time(build_dir / manifest_file_name);
    }

    inline bool
    is_outdated(const fs::path& build_dir) {
        if (!fs::exists(build_dir / manifest_file_name)) {
            return true;
        }
        using poac::data::manifest::poac_toml_last_modified;
        return ninja_manifest_last_modified(build_dir)
             < poac_toml_last_modified(config::path::current);
    }

    bool
    rebuild(data::NinjaMain& ninja_main, Status& status, std::string& err) {
        Node* node = ninja_main.state.LookupNode(
            (ninja_main.build_dir / manifest_file_name).string()
        );
        if (!node) {
            return false;
        }

        Builder builder(
            &ninja_main.state,
            ninja_main.config,
            &ninja_main.build_log,
            &ninja_main.deps_log,
            &ninja_main.disk_interface,
            &status,
            ninja_main.start_time_millis
        );
        if (!builder.AddTarget(node, &err)) {
            return false;
        }
        if (builder.AlreadyUpToDate()) {
            return false; // Not an error, but we didn't rebuild.
        }
        if (!builder.Build(&err)) {
            return false;
        }

        // The manifest was only rebuilt if it is now dirty (it may have been cleaned
        // by a restat).
        if (!node->dirty()) {
            // Reset the state to prevent problems like
            // https://github.com/ninja-build/ninja/issues/874
            ninja_main.state.Reset();
            return false;
        }
        return true;
    }

    [[nodiscard]] anyhow::result<std::string>
    construct(
        const fs::path& build_dir,
        const toml::value& poac_manifest,
        const resolver::resolved_deps_t& resolved_deps
    ) {
        syntax::writer writer{ std::ostringstream() };
        for (const auto& header : manifest_headers) {
            writer.comment(header);
        }
        writer.newline();

        // Assuming no dependency package for test
        if (resolved_deps.empty()) {}
        const auto cpp = toml::find<toml::integer>(poac_manifest, "package", "cpp");
        const std::string command = MITAMA_TRY(compiler::cxx::get_command(cpp, false));

        writer.rule(
            "compile",
            fmt::format("{} $in -o $out", command),
            syntax::rule_set_t{
                .description = fmt::format(
                    "{} v{} ({})",
                    toml::find<std::string>(poac_manifest, "package", "name"),
                    toml::find<std::string>(poac_manifest, "package", "version"),
                    config::path::current.string()
                ),
            }
        );
        writer.newline();

        using namespace util::misc::path_literals;
        const fs::path source_file = "src"_path / "main.cpp";
        const fs::path output_file = (build_dir / source_file).string() + ".o";
        fs::create_directories(output_file.parent_path());
        writer.build(
            {output_file.string()},
            "compile",
            syntax::build_set_t{
                .inputs = std::vector{source_file.string()}
            }
        );
        writer.newline();

        writer.default_({output_file.string()});
        return mitama::success(writer.get_value());
    }

    [[nodiscard]] anyhow::result<void>
    create(
        const fs::path& build_dir,
        const toml::value& poac_manifest,
        const resolver::resolved_deps_t& resolved_deps
    ) {
        // `ninja.build` will be constructed from `poac.toml`,
        // so if `poac.toml` has no change,
        // then `ninja.build` is not needed to be updated.
//        if (is_outdated(build_dir)) {
            std::ofstream ofs(build_dir / manifest_file_name, std::ios::out);
            ofs << MITAMA_TRY(construct(build_dir, poac_manifest, resolved_deps));
//        }
        return mitama::success();
    }
}

#endif // !POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
