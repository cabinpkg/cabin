#ifndef POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
#define POAC_CORE_BUILDER_NINJA_MANIFEST_HPP

// std
#include <array>
#include <filesystem>
#include <fstream>
#include <optional>
#include <string>
#include <utility> // std::make_pair

// external
#include <boost/algorithm/string.hpp> // boost::algorithm::join
#include <fmt/core.h>
#include <mitama/result/result.hpp>
#include <mitama/anyhow/anyhow.hpp>
#include <ninja/build.h> // Builder
#include <ninja/graph.h> // Node
#include <toml.hpp>

// internal
#include <poac/core/builder/ninja/syntax.hpp>
#include <poac/core/builder/ninja/data.hpp>
#include <poac/core/builder/compiler.hpp>
#include <poac/core/resolver.hpp> // resolved_deps_t, get_extracted_path
#include <poac/data/manifest.hpp>
#include <poac/util/cfg.hpp>
#include <poac/util/misc.hpp>
#include <poac/config.hpp>

namespace poac::core::builder::ninja::manifest {
    namespace fs = std::filesystem;
    namespace anyhow = mitama::anyhow;

    inline const std::string manifest_file_name = "ninja.build";
    inline const std::array<std::string, 2> manifest_headers = {
        "This file is automatically generated by Poac.",
        "It is not intended for manual editing."
    };

    inline fs::file_time_type
    ninja_manifest_last_modified(const fs::path& build_dir) {
        return fs::last_write_time(build_dir / manifest_file_name);
    }

    inline bool
    is_outdated(const fs::path& build_dir) {
        if (!fs::exists(build_dir / manifest_file_name)) {
            return true;
        }
        using poac::data::manifest::poac_toml_last_modified;
        return ninja_manifest_last_modified(build_dir)
             < poac_toml_last_modified(config::path::current);
    }

    bool
    rebuild(data::NinjaMain& ninja_main, Status& status, std::string& err) {
        Node* node = ninja_main.state.LookupNode(
            (ninja_main.build_dir / manifest_file_name).string()
        );
        if (!node) {
            return false;
        }

        Builder builder(
            &ninja_main.state,
            ninja_main.config,
            &ninja_main.build_log,
            &ninja_main.deps_log,
            &ninja_main.disk_interface,
            &status,
            ninja_main.start_time_millis
        );
        if (!builder.AddTarget(node, &err)) {
            return false;
        }
        if (builder.AlreadyUpToDate()) {
            return false; // Not an error, but we didn't rebuild.
        }
        if (!builder.Build(&err)) {
            return false;
        }

        // The manifest was only rebuilt if it is now dirty (it may have been cleaned
        // by a restat).
        if (!node->dirty()) {
            // Reset the state to prevent problems like
            // https://github.com/ninja-build/ninja/issues/874
            ninja_main.state.Reset();
            return false;
        }
        return true;
    }

    std::vector<std::string>
    gather_includes(const resolver::resolved_deps_t& resolved_deps) {
        std::vector<std::string> includes;
        for (const auto& [package, inner_deps] : resolved_deps) {
            static_cast<void>(inner_deps);

            const auto include_path = resolver::get_extracted_path(package) / "include";
            if (fs::exists(include_path) && fs::is_directory(include_path)) {
                includes.emplace_back(fmt::format("-I{}", include_path.string()));
            }
        }
        return includes;
    }

    std::vector<toml::table>
    get_cfg_profile(const toml::value& poac_manifest) {
        const auto target = toml::find_or<toml::table>(
            poac_manifest, "target", toml::table{}
        );
        std::vector<toml::table> profiles;
        for (const auto& [key, val] : target) {
            if (key.find("cfg(") != std::string::npos) {
                if (util::cfg::parse(key).match()) {
                    const auto profile = toml::find_or<toml::table>(
                        val, "profile", toml::table{}
                    );
                    profiles.emplace_back(profile);
                }
            }
        }
        return profiles;
    }

    std::vector<std::string>
    gather_flags(
        const toml::value& poac_manifest,
        const std::string& name,
        const std::optional<std::string>& prefix=std::nullopt
    ) {
        auto f = toml::find_or<std::vector<std::string>>(
            poac_manifest, "target", "profile", name, std::vector<std::string>{}
        );
        if (prefix.has_value()) {
            std::transform(
                f.begin(), f.end(), f.begin(),
                [p=prefix.value()](const auto& s){ return p + s; }
            );
        }
        return f;
    }

    [[nodiscard]] anyhow::result<std::string>
    construct(
        const fs::path& build_dir,
        const toml::value& poac_manifest,
        const resolver::resolved_deps_t& resolved_deps
    ) {
        syntax::writer writer{ std::ostringstream() };
        for (const auto& header : manifest_headers) {
            writer.comment(header);
        }
        writer.newline();

        const auto cpp = toml::find<toml::integer>(poac_manifest, "package", "cpp");
        const std::string command = MITAMA_TRY(compiler::cxx::get_command(cpp, false));

        writer.rule(
            "compile",
            fmt::format("{} $OPTIONS $DEFINES $INCLUDES $LIBRARIES $in -o $out", command),
            syntax::rule_set_t{
                .description = "$PACKAGE_NAME v$PACKAGE_VERSION $PACKAGE_PATH",
            }
        );
        writer.newline();

        using namespace util::misc::path_literals;
        const fs::path source_file = "src"_path / "main.cpp";
        const fs::path output_file = (build_dir / source_file).string() + ".o";
        fs::create_directories(output_file.parent_path());
        const auto includes = gather_includes(resolved_deps);

        const auto defines = gather_flags(poac_manifest, "definitions", "-D");
        const auto options = gather_flags(poac_manifest, "options");
        const auto libraries = gather_flags(poac_manifest, "libraries", "-l");

        writer.build(
            {output_file.string()},
            "compile",
            syntax::build_set_t{
                .inputs = std::vector{source_file.string()},
                .variables = syntax::variables_t{
                    {"PACKAGE_NAME", toml::find<std::string>(poac_manifest, "package", "name")},
                    {"PACKAGE_VERSION", toml::find<std::string>(poac_manifest, "package", "version")},
                    {"PACKAGE_PATH", fmt::format("({})", config::path::current.string())},
                    {"OPTIONS", boost::algorithm::join(options, " ")},
                    {"DEFINES", boost::algorithm::join(defines, " ")},
                    {"INCLUDES", boost::algorithm::join(includes, " ")},
                    {"LIBRARIES", boost::algorithm::join(libraries, " ")},
                },
            }
        );
        writer.newline();

        writer.default_({output_file.string()});
        return mitama::success(writer.get_value());
    }

    [[nodiscard]] anyhow::result<void>
    create(
        const fs::path& build_dir,
        const toml::value& poac_manifest,
        const resolver::resolved_deps_t& resolved_deps
    ) {
        // `ninja.build` will be constructed from `poac.toml`,
        // so if `poac.toml` has no change,
        // then `ninja.build` is not needed to be updated.
//        if (is_outdated(build_dir)) {
            std::ofstream ofs(build_dir / manifest_file_name, std::ios::out);
            ofs << MITAMA_TRY(construct(build_dir, poac_manifest, resolved_deps));
//        }
        return mitama::success();
    }
}

#endif // !POAC_CORE_BUILDER_NINJA_MANIFEST_HPP
